#version 430
#extension GL_ARB_shader_atomic_counter_ops : require
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 4) uniform atomic_uint vert_count;

uniform ivec3 res;
uniform float threshold;
layout(std430, binding = 0) buffer field_buff
{
    vec4[] field;
};

layout(std430, binding = 1) buffer vert_buff
{
    vec3[] vertices;
};
layout(std430, binding = 2) buffer uv_buff
{
    vec2[] uvs;
};
layout(std430, binding = 3) buffer norm_buff
{
    vec3[] normals;
};
layout(std430, binding = 5) buffer triangulation_buff
{
    int[256][16] triangulation;
};

ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);

const int edge_corner_A[12] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    0,
    1,
    2,
    3
};

const int edge_corner_B[12] = {
    1,
    2,
    3,
    0,
    5,
    6,
    7,
    4,
    4,
    5,
    6,
    7
};

int field_index(ivec3 loc)
{
    return loc.z*res.x*res.y + loc.y*res.x + loc.x;
}

vec3 interp_vert(vec4 a, vec4 b)
{
    float t = (threshold - a.w) / (b.w-a.w);

    float x = mix(a.x, b.x, t);
    float y = mix(a.y, b.y, t);
    float z = mix(a.z, b.z, t);

    return vec3(x, y, z);
}

vec3 homogenize(vec3 p)
{
    float half_largest_dim = (max(res.x, max(res.y, res.z))+2)/2;
    return (p / half_largest_dim) - 1;
}

void main()
{
    int x = pos.x-1;
    int y = pos.y-1;
    int z = pos.z-1;
    
    vec4 cube_corners[8];
    cube_corners[0] = vec4(x,   y,   z,   1);
    cube_corners[1] = vec4(x+1, y,   z,   1);
    cube_corners[2] = vec4(x+1, y,   z+1, 1);
    cube_corners[3] = vec4(x,   y,   z+1, 1);
    cube_corners[4] = vec4(x,   y+1, z,   1);
    cube_corners[5] = vec4(x+1, y+1, z,   1);
    cube_corners[6] = vec4(x+1, y+1, z+1, 1);
    cube_corners[7] = vec4(x,   y+1, z+1, 1);
    
    if (x != -1      && y != -1      && z != -1)
        cube_corners[0] = field[field_index(ivec3(x,   y,   z))];
    if (x != res.x-1 && y != -1      && z != -1)
        cube_corners[1] = field[field_index(ivec3(x+1, y,   z))];
    if (x != res.x-1 && y != -1      && z != res.z-1)
        cube_corners[2] = field[field_index(ivec3(x+1, y,   z+1))];
    if (x != -1      && y != -1      && z != res.z-1)
        cube_corners[3] = field[field_index(ivec3(x,   y,   z+1))];
    if (x != -1      && y != res.y-1 && z != -1)
        cube_corners[4] = field[field_index(ivec3(x,   y+1, z))];
    if (x != res.x-1 && y != res.y-1 && z != -1)
        cube_corners[5] = field[field_index(ivec3(x+1, y+1, z))];
    if (x != res.x-1 && y != res.y-1 && z != res.z-1)
        cube_corners[6] = field[field_index(ivec3(x+1, y+1, z+1))];
    if (x != -1      && y != res.y-1 && z != res.z-1)
        cube_corners[7] = field[field_index(ivec3(x,   y+1, z+1))];

    int variation_index = 0;
    if (cube_corners[0].w < threshold) variation_index |= 1;
    if (cube_corners[1].w < threshold) variation_index |= 2;
    if (cube_corners[2].w < threshold) variation_index |= 4;
    if (cube_corners[3].w < threshold) variation_index |= 8;
    if (cube_corners[4].w < threshold) variation_index |= 16;
    if (cube_corners[5].w < threshold) variation_index |= 32;
    if (cube_corners[6].w < threshold) variation_index |= 64;
    if (cube_corners[7].w < threshold) variation_index |= 128;

    const int[16] tris = triangulation[variation_index];
    // int count = 0;
    // while (tris[count] != -1) count++;
    // uint base_index = atomicCounterAddARB(vert_count, count);
    
    for (int i = 0; tris[i] != -1; i+=3)
    {
        int a0 = edge_corner_A[tris[i]];
        int b0 = edge_corner_B[tris[i]];

        int a1 = edge_corner_A[tris[i+1]];
        int b1 = edge_corner_B[tris[i+1]];

        int a2 = edge_corner_A[tris[i+2]];
        int b2 = edge_corner_B[tris[i+2]];

        vec3 vert0 = interp_vert(cube_corners[a0], cube_corners[b0]);
        vec3 vert1 = interp_vert(cube_corners[a1], cube_corners[b1]);
        vec3 vert2 = interp_vert(cube_corners[a2], cube_corners[b2]);

        vec3 edge0  = vert1 - vert0;
        vec3 edge1  = vert2 - vert0;
        vec3 normal = normalize(cross(edge0, edge1));

        uint index = atomicCounterAddARB(vert_count, 3);

        vertices[index]   = homogenize(vert0);
        vertices[index+1] = homogenize(vert1);
        vertices[index+2] = homogenize(vert2);

        normals[index]   = normal;
        normals[index+1] = normal;
        normals[index+2] = normal;

        uvs[index]   = vec2(0, 0);
        uvs[index+1] = vec2(0, 1);
        uvs[index+2] = vec2(1, 0);
    }
}
