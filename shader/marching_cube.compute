#version 430
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform ivec3 res;
uniform float threshold;
layout(std430, binding = 0) buffer field_buff
{
    vec4[] field;
};

layout(std430, binding = 1) buffer vert_buff
{
    vec3[] vertices;
};
layout(std430, binding = 2) buffer norm_buff
{
    vec3[] normals;
};
layout(std430, binding = 3) buffer uv_buff
{
    vec2[] uvs;
};

ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);

void main()
{
    for (int z = -1; z < res.z; z++)
    {
        for (int y = -1; y < res.y; y++)
        {
            for (int x = -1; x < res.x; x++)
            {
                Vec4f cube_corners[8] = {0};
                cube_corners[0] = init_vec4f(x,   y,   z,   1);
                cube_corners[1] = init_vec4f(x+1, y,   z,   1);
                cube_corners[2] = init_vec4f(x+1, y,   z+1, 1);
                cube_corners[3] = init_vec4f(x,   y,   z+1, 1);
                cube_corners[4] = init_vec4f(x,   y+1, z,   1);
                cube_corners[5] = init_vec4f(x+1, y+1, z,   1);
                cube_corners[6] = init_vec4f(x+1, y+1, z+1, 1);
                cube_corners[7] = init_vec4f(x,   y+1, z+1, 1);
                
                if (x != -1      && y != -1      && z != -1)
                    cube_corners[0] = field[field_index(init_vec3f(x,   y,   z),   res)];
                if (x != res.x-1 && y != -1      && z != -1)
                    cube_corners[1] = field[field_index(init_vec3f(x+1, y,   z),   res)];
                if (x != res.x-1 && y != -1      && z != res.z-1)
                    cube_corners[2] = field[field_index(init_vec3f(x+1, y,   z+1), res)];
                if (x != -1      && y != -1      && z != res.z-1)
                    cube_corners[3] = field[field_index(init_vec3f(x,   y,   z+1), res)];
                if (x != -1      && y != res.y-1 && z != -1)
                    cube_corners[4] = field[field_index(init_vec3f(x,   y+1, z),   res)];
                if (x != res.x-1 && y != res.y-1 && z != -1)
                    cube_corners[5] = field[field_index(init_vec3f(x+1, y+1, z),   res)];
                if (x != res.x-1 && y != res.y-1 && z != res.z-1)
                    cube_corners[6] = field[field_index(init_vec3f(x+1, y+1, z+1), res)];
                if (x != -1       && y != res.y-1 && z != res.z-1)
                    cube_corners[7] = field[field_index(init_vec3f(x,   y+1, z+1), res)];

                int variation_index = 0;
                if (cube_corners[0].w < threshold) variation_index |= 1;
                if (cube_corners[1].w < threshold) variation_index |= 2;
                if (cube_corners[2].w < threshold) variation_index |= 4;
                if (cube_corners[3].w < threshold) variation_index |= 8;
                if (cube_corners[4].w < threshold) variation_index |= 16;
                if (cube_corners[5].w < threshold) variation_index |= 32;
                if (cube_corners[6].w < threshold) variation_index |= 64;
                if (cube_corners[7].w < threshold) variation_index |= 128;

                const int *tris = triangulation[variation_index];
                for (int i = 0; tris[i] != -1; i+=3)
                {
                    int a0 = edge_corner_A[tris[i]];
                    int b0 = edge_corner_B[tris[i]];

                    int a1 = edge_corner_A[tris[i+1]];
                    int b1 = edge_corner_B[tris[i+1]];

                    int a2 = edge_corner_A[tris[i+2]];
                    int b2 = edge_corner_B[tris[i+2]];

                    /* Vec3f vert0 = interp_vert(cube_corners[a0], cube_corners[b0], threshold); */
                    /* Vec3f vert1 = interp_vert(cube_corners[a1], cube_corners[b1], threshold); */
                    /* Vec3f vert2 = interp_vert(cube_corners[a2], cube_corners[b2], threshold); */
                    
                    Vec3f vert0 = midpoint(cube_corners[a0], cube_corners[b0]);
                    Vec3f vert1 = midpoint(cube_corners[a1], cube_corners[b1]);
                    Vec3f vert2 = midpoint(cube_corners[a2], cube_corners[b2]);

                    Vec3f edge0  = vec3f_sub(vert1, vert0);
                    Vec3f edge1  = vec3f_sub(vert2, vert0);
                    Vec3f normal = vec3f_normalize(vec3f_cross(edge0, edge1));

                    array_append(&m.vertices, homogenize(vert0, res));
                    array_append(&m.vertices, homogenize(vert1, res));
                    array_append(&m.vertices, homogenize(vert2, res));

                    array_append(&m.normals, normal);
                    array_append(&m.normals, normal);
                    array_append(&m.normals, normal);

                    array_append(&m.uvs, init_vec2f(0, 0));
                    array_append(&m.uvs, init_vec2f(0, 1));
                    array_append(&m.uvs, init_vec2f(1, 0));
                }
            }
        }
    }
}
