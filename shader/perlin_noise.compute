#version 430
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform ivec3 res;
layout(std430, binding = 0) buffer field_buff
{
    vec4[] field;
};
layout(std430, binding = 1) buffer gradient_buff
{
    vec3[] gradients;
};

float dot_grid_gradient(ivec3 ipos, vec3 pos)
{
    float dx = pos.x - float(ipos.x);
    float dy = pos.y - float(ipos.y);
    float dz = pos.z - float(ipos.z);

    vec3 grad = gradients[ipos.z*res.x*res.y + ipos.y*res.x + ipos.x];

    return dot(vec3(dx, dy, dz), grad);
}

ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);

void main()
{
  
    vec3 scaled_pos = vec3(pos) / (min(res.x, min(res.y, res.z))/3);

    // Determine grid cell coordinates
    int x0 = int(scaled_pos.x);
    int x1 = x0 + 1;
    int y0 = int(scaled_pos.y);
    int y1 = y0 + 1;
    int z0 = int(scaled_pos.z);
    int z1 = z0 + 1;

    // Determine interpolation weights
    // Could also use higher order polynomial/s-curve here
    float sx = scaled_pos.x - float(x0);
    float sy = scaled_pos.y - float(y0);
    float sz = scaled_pos.z - float(z0);
    
    // Interpolate between grid point gradients
    float n0, n1, ix0, ix1, iy0, iy1;

    n0 = dot_grid_gradient(ivec3(x0, y0, z0), scaled_pos);
    n1 = dot_grid_gradient(ivec3(x1, y0, z0), scaled_pos);
    ix0 = mix(n0, n1, sx);

    n0 = dot_grid_gradient(ivec3(x0, y1, z0), scaled_pos);
    n1 = dot_grid_gradient(ivec3(x1, y1, z0), scaled_pos);
    ix1 = mix(n0, n1, sx);

    iy0 = mix(ix0, ix1, sy);
    
    n0 = dot_grid_gradient(ivec3(x0, y0, z1), scaled_pos);
    n1 = dot_grid_gradient(ivec3(x1, y0, z1), scaled_pos);
    ix0 = mix(n0, n1, sx);

    n0 = dot_grid_gradient(ivec3(x0, y1, z1), scaled_pos);
    n1 = dot_grid_gradient(ivec3(x1, y1, z1), scaled_pos);
    ix1 = mix(n0, n1, sx);

    iy1 = mix(ix0, ix1, sy);

    field[pos.z*res.x*res.y + pos.y*res.x + pos.x] = vec4(pos, mix(iy0, iy1, sz));
}
